# 🧠 다이나믹 프로그래밍 (DP, Dynamic Programming)

> 복잡한 문제를 효율적으로 푸는 핵심 알고리즘  
> **"작은 문제들의 결과를 저장하고 재활용해서 전체 문제를 빠르게 푸는 방식"**

---

## 🎒 예시: 계단 오르기 문제

### 문제 설명

- 너는 계단을 오른다.
- 한 번에 **1칸 또는 2칸**을 오를 수 있다.
- 총 `N`칸 계단이 있을 때, 정상에 도달하는 **경우의 수**는?

---

### 👣 예시로 살펴보기

| 계단 수 | 경우의 수 | 방법 |
|--------|-----------|------|
| 1칸    | 1         | [1] |
| 2칸    | 2         | [1+1], [2] |
| 3칸    | 3         | [1+1+1], [1+2], [2+1] |

---

## 🔁 규칙 찾기 (점화식)

- `stairs(n) = stairs(n-1) + stairs(n-2)`
- 현재 계단의 경우의 수는  
  👉 **한 칸 전 + 두 칸 전**의 경우의 수

---

## ❌ 비효율적인 방식 (재귀)

```csharp
int stairs(int n)
{
    if (n == 1) return 1;
    if (n == 2) return 2;
    return stairs(n - 1) + stairs(n - 2);
}
같은 값을 계속 계산해서 느려짐
```
예: stairs(5)를 구하려면 stairs(4)와 stairs(3)을 또 각각 호출함

## ✅ 효율적인 방식 (DP)
```csharp
int[] dp = new int[n + 1];
dp[1] = 1;
dp[2] = 2;

for (int i = 3; i <= n; i++)
{
    dp[i] = dp[i - 1] + dp[i - 2];
}
```
한 번 계산한 값을 배열(dp)에 저장

중복 계산 없음 → 매우 빠름

## 💼 현실 비유: 출근 경로 계산
회사까지 가는 길은 총 10구간

매일 1칸 또는 2칸씩 이동 가능

어제까지 계산한 출근 방법을 기억하고 있다면?
→ 오늘의 경로는 빠르게 계산 가능!

## 📌 핵심 요약
- 작은 문제로 쪼개기	큰 문제를 작게 나눔
- 결과 저장	중복 계산 방지
- 점화식 사용	현재 값을 이전 값들로 정의
- 배열 사용	dp[i] 형태로 결과를 저장
- 활용 예시	계단 오르기, 출근 경로, 동전 문제, 피보나치 수열 등

## 🧠 언제 DP를 쓰면 좋을까?
- 같은 계산을 반복하고 있다면

- 문제를 작은 문제로 나눌 수 있다면

- 전에 계산한 결과가 다시 필요하다면
